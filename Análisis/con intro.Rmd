---
title: "Trabajo Final Muestreo"
author: "Fabricio Camacho y Luciana Viscailuz"
output: 
  html_document:
    fig_caption: true
date: "2024-07-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F,fig.cap = T)
```


<style>
.caption {
  text-align: center;
}
</style>

<style>
caption {
  caption-side: bottom;
  text-align: center;
}
</style>

# INTRODUCCIÓN


El objetivo de este proyecto es realizar estimaciones de diferentes parámetros a partir de varios de los metodos ya vistos en clase.
Para cumplir el objetivo la obtención de la muestra es una etapa clave. Para esta se comenzó seleccionando una muestra aleatoria de los hogares de Montevideo bajo un
diseño estratificado, por conglomerados y en dos etapas de selección. Siendo las UPM las manzanas y la USM los hogares.
Para la selección de las UPM y posteriormente las USM se combinaron diferentes diseños según lo pautado.
Finalmente, una vez obtenidas las muestras y las estimaciones se realizaron comparaciones obteniendo así diferentes conclusiones.



### Paquetes
```{r, warning=FALSE, message=FALSE, echo=T}
library(tidyverse)
library(survey)
library(srvyr)
library(sampling)
library(here)
library(kableExtra)
library(e1071)
library(moments)


options(scipen = 9999)

```

```{r,warning=FALSE, message=FALSE,}
U <- read_csv(here("Datos/Montevideo GR1.csv"))
```





# Analisis previo

```{r}

summary(U) %>%
  kable(.,caption="Tabla 1: Medidas de resumen") %>%
  kable_styling(position = "center", latex_options = "HOLD_position") %>%  kable_classic_2()

```

### Totales

Se cuenta con la información de 452.721 hogares donde cada uno pertenece a una de las 3480 manzanas. 
Para cada hogar se tiene la información de la cantidad de personas que habitan en él y si estas personas están ocupadas, desocupadas o ninguna de las anteriores, que se entiende como personas que no trabajan ni buscan hacerlo. 
Observando la tabla se puede notar que la media de los ocupados, 1,323, es mucho mayor que la de los desocupados, 0.1265.
Además se tiene la información de si los hogares alquilan o no y cuánto pagan por ello.
La media del precio del alquiler se encuentra en 33.713, mientras que el ingreso promedio del hogar está en 4653, una diferencia muy notable.


```{r}
# computamos totales de las variables y N
pop_total = U %>% summarise(Total_personas=sum(cant_personas),
                 Desocupados=sum(desocupados),
                 Ocupados=sum(ocuopados),
                 Pobres=sum(pobre),
                 Total_hogares=n())%>%
                 kable(.,caption="Tabla 2: Totales de principales variables")%>%
                kable_styling(position = "center", latex_options = "HOLD_position") %>%  kable_classic_2()
pop_total

```

# RESULTADOS



**1. Calcule el tamano de muestra para obtener un margen de error de ±3% a un 95%**
**de confianza para estimar cualquier proporcion poblacional. Asuma un efecto de diseno de 1.5.**

Para obtener el tamaño de muestra para cualquier proporción se utilizó la formula:

  $$n = ((z^2 * p*(1-p))/moe^2)*moe$$ 

Como se pedía un 95% de confianza, $\alpha$ tomó el valor de 0.05. Llevando a que $z_{(1-\sigma)}$  fuera el valor de la distribución normal en el cuantil 0.975.
Posteriormente se asumió que p tomaba el valor de 0.5 y se sustituyó moe (margen de error) por 0.03, tal como pide la letra.
Finalmente el tamaño de la muestra quedó en **1601**





```{r}

n = round((((1.96^2 * 0.5 * (1-0.5)) / 0.03^2) * 1.5 ),0)

```





**2. Con el tamano de muestra calculado en el punto anterior, asigne el mismo por estrato de forma optima, utilizando como variable auxiliar el ingreso del hogar.**

Se comenzó calculando para cada estrato su tamaño y las medidas de resumen (total, promedio y desvío) de la variable auxiliar, ingreso_hog.
Posteriormente, algunos de estos resultados fueron utilizados junto con el tamaño de muestra calculado en el punto anterior para obtener el tamaño de muestra de cada estrato según la asignación optima. 

\[ 
n_h = n \times \frac{N_h \text{sd}_{dU_h}[y]}{\sum_{h=1}^{H} N_h \text{sd}_{dU_h}[y]}
\]

```{r}


U %>% 
  group_by(estrato) %>% 
  summarise(N=n(),
            tot_ing=sum(ingreso_hog),
            prom_ing=mean(ingreso_hog),
            sd_ig=sd(ingreso_hog),) %>%
            mutate(n_opt=round(n*N*sd_ig/sum(N*sd_ig),0))%>%
            rename(.,Estrato=estrato,
                   N_h=N,
                    Total_ingreso=tot_ing,
                   Promedio_ingreso=prom_ing,
                   SE_ingreso=sd_ig,
                   Tamaño_optimo=n_opt)%>%
            as.data.frame(.)%>%
                 kable(.,caption="Tabla 3: Tamaño de la muestra por asignacion estratificada según ingreso")%>%
                kable_styling(position = "center", latex_options = "HOLD_position") %>%  kable_classic_2()




```


```{r, echo=F}
tam = U %>% 
  group_by(estrato) %>% 
  summarise(N=n(),
            tot_ing=sum(ingreso_hog),
            prom_ing=mean(ingreso_hog),
            sd_ig=sd(ingreso_hog),) %>%
            mutate(n_opt=round(n*N*sd_ig/sum(N*sd_ig),0))%>%
            rename(.,N_h=N,
                    Total_ingreso=tot_ing,
                   Promedio_ingreso=prom_ing,
                   SE_ingreso=sd_ig,
                   Tamaño_optimo=n_opt)


```




**3. Seleccione una muestra bajo el diseño propuesto (aleatorio, estratificado, por conglomerados y en 2 etapas de selección).**
**Utilice como semilla el número de grupo al que pertenece.**


Para obtener la muestra final de hogares, se comenzó seleccionando m manzanas en cada estrato bajo un diseño PPS sin reemplazo, donde la probabilidad de que cada manzana fuera seleccionada dependía de la cantidad de personas que habitaban en ella, es decir, mientras mayor población existía en la manzana mayor probabilidad tenía esta de ser seleccionada. Dicho m se calculó tomando en cuenta el tamaño de muestra óptimo en cada estrato y que posteriormente se iban a extrarer cinco viviendas de cada manzana.

Obtenida la muestra de UPMs de cada estrato, se seleccionaron cinco viviendas de cada manzana bajo un diseño simple.

Finalmente, la muestra de hogares quedó conformada por cada uno de los cinco hogares extraídos de cada una de las manzanas seleccionadas de cada estrato. Se puede afirmar que en la muestra final hay hogares de los diferentes niveles socioeconomicos.



```{r, echo=T, message=F}


Muestra = list("Estrato 1"=0,"Estrato 2"=0,"Estrato 3"=0,"Estrato 4"=0,"Estrato 5"=0)

tamano= tam %>% as.data.frame(.)%>% select(.,Tamaño_optimo) %>% as.vector(.)


for(i in 1:5) {
  
#Primera etapa

m=round(tamano[["Tamaño_optimo"]][i]/5,0) #Cantidad de manzanas que se seleccionan de cada estrato

#Cantidad de personas por UPM (manzana)
U_upm_estrato = U %>% filter(,estrato==i) %>%  group_by(manzana) %>% summarise(MOS=sum(n())) %>% arrange(MOS)


#Se seleccionan m manzanas del estrato
set.seed(1)

s_upm=sampling::strata(data=U_upm_estrato,
                    stratanames = NULL,
                    size=m,
                    method='systematic',
                    pik=U_upm_estrato$MOS)

s_upm = getdata(U_upm_estrato,s_upm) %>% rename(prob_upm=Prob)


#Segunda etapa

#Se seleccionan bajo un Diseño simple 5 hogares de cada manzana seleccionada.

U_usm= U %>% left_join(s_upm %>% select(manzana,prob_upm)) %>% filter(is.na(prob_upm)==FALSE)

U_usm= U_usm %>% arrange(manzana)

set.seed(1)

s= sampling::strata(data=U_usm,
                    stratanames = 'manzana',
                    size=rep(5,m),
                    method='srswor')

s = getdata(U_usm,s) %>% rename(prob_usm=Prob)
  

Muestra[[i]]=s
  
}

S = tibble::as_tibble(rbind(Muestra[[1]],Muestra[[2]],Muestra[[3]],Muestra[[4]],Muestra[[5]])) %>%
  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)



```

**4. Calcule la estimacion puntual del ingreso promedio, proporcion de hogares pobres y total de personas ,a nivel de toda la población**

**Para cada estimacion se debe computar:**
 **- Error estandar (SE)**
 **- Coeficiente de variacion**
 **- Efecto de diseno**
 **- Margenes de error al 95%.**
  

```{r,echo=F}

#Diseño estratificado en dos etapas 
ps_pps = S %>% svydesign(ids=~manzana+ID,
                        strata = ~estrato, 
                     weights=~w,
                     data=.)


#Ingreso promedio

ingreso_promedio_gorro = cross_join( as.data.frame(svymean(~ingreso_hog,ps_pps,deff=T)),
                                     as.data.frame(confint(svymean(~ingreso_hog,ps_pps,deff=T))))%>%
                          rename(.,Estimacion_puntual=mean,SE=ingreso_hog,Deff=deff)%>%
                              mutate(.,CV=SE/Estimacion_puntual)


#Proporcion de hogares pobres


hogares_pobres_gorro = cross_join( as.data.frame(svymean(~pobre,ps_pps,deff=T)),
                                     as.data.frame(confint(svymean(~pobre,ps_pps,deff=T))))%>%
                            rename(.,Estimacion_puntual=mean,SE=pobre,Deff=deff)%>%
                              mutate(.,CV=SE/Estimacion_puntual)


#Total de personas

total_personas_gorro = cross_join( as.data.frame(svytotal(~cant_personas,ps_pps,deff=T)),
                                   as.data.frame(confint(svytotal(~cant_personas,ps_pps,deff=T))))%>%
                          rename(.,Estimacion_puntual=total,SE=cant_personas,Deff=deff)%>%
  mutate(.,CV=SE/(Estimacion_puntual) )

#Totales

estimadores =round(rbind(ingreso_promedio_gorro,hogares_pobres_gorro,total_personas_gorro),3)%>%
  select(.,1,2,6,4,5,3)

rownames(estimadores) <- c("Ingreso promedio","Proporcion hogares pobres","Total de personas")

estimadores%>%
  kable(.,caption="Tabla 4: Estimadores de ingreso promedio, hogares pobres y total de personas")%>%
  kable_styling(position = "center", latex_options = "HOLD_position")%>%
  kable_classic_2()

```
 Para cada una de las estimaciones se obtuvo su error estándar que muestra cuanto podría variar la estimación si se repitiera el muestreo muchas veces. En relación con las estimaciones, los errores no son muy altos, lo que permite interpretar que las estimaciones están cercas del verdadero valor a estimar.
 

Observamos una mayor variación en cuanto a la variabilidad respecto a la media de la proporción de hogares pobres, siendo las estimaciónes más precisas la del ingreso promedio y el total de personas con un **1.2%** y **2.1%** respectivamente. Por otra parta la proporción de hogares pobres varía en un **12.6%**

Los intervalos de confianza obtenidos nos indican la precisión de nuestras estimaciones, en la tabla se puede ver que los intervalos son dentro de todo estrechos, por lo que las estimaciones realizadas son bastantes precisas.

Por último, se obtiene el deff para cada estimación, estos dieron mayores a uno, indicando que el diseño aplicado es menos eficiente que el MAS, esto se podría deber a estar utilizando un diseño complejo en el que los ponderadores varían dependiendo de cada etapa de selección, también en un diseño por conglomerados, en el que estos son tanto heterogeneos entre si como homogeneos dentro, logrando información similar en cada conglomerado pero variable en el conjunto de datos, una forma de mejorar la eficiencia bajó estas hipótesis, es la de aumentar la cantidad de conglomerados, consiguiendo así suficiente información.

**5. Para computar los errores estándar del punto anterior, ¿qué método para estimar varianza se utilizó?**

Para estimar la varianza se utilizó el método del último conglomerado junto con la linealización de Taylor. En este método se asume que la mayor variabilidad en la estimación proviene de la primera etapa del muestreo y que las manzanas (UPM) son seleccionadas con reposición. Luego el método de la linealización de Taylor realiza una aproximación lineal del estimador y permite estimar la varianza utilizando métodos para estimadores lineales.

`Survey`, el paquete que se utilizó en el punto anterior por defecto utiliza la formula: 

\[ 
\hat{V}_{UC} = \frac{1}{n_I(n_I-1)}\sum\limits_{i\in s_I}\left(\hat{Y}_i - \hat{Y}\right)^2
\]


 **6. Calcule el ingreso per cápita en Montevideo (junto con su error estándar).**
**Indique el tipo de parámetro y qué método fue utilizado por defecto por el paquete survey para la estimación del error estándar.**


En este punto se obtiene un estimador complejo denominado "Ratio", debido a que surge como cociente de dos totales, ingresos totales en Montevideo y cantidad de habitantes. Para realizar su estimación se debió contar previamente con la estimación de dichos totales.

Por defecto, el paquete `survey` utiliza la "Linealización de Taylor" y se aproxima $\\hat{\\theta}$, el parámetro de interés, por su desarrollo de primer orden. Como se utiliza una aproximación del parámetro, finalmente se obtiene la varianza del pseudo-estimador que es la que se conoce como la aproximación de la varianza.

\[
\hat{V}(\hat{\theta}) = \sum_{i \in s} \sum_{j \in s} \frac{\Delta_{ij}}{\pi_{ij}} \frac{\hat{u}_i}{\pi_i} \frac{\hat{u}_j}{\pi_j}
\]

Siendo

\[
\hat{u}_i = \sum\limits_{q=1}^Q \hat{a}_q y_{qi}
\]


Al realizarle la raíz cuadrada a la estimación de la varianza se obtiene finalmente el ${\sigma}$.


```{r, echo=F,message=F}

# Calcular la estimación de razón


ratio_est <- svyratio(numerator = ~ingreso_hog,
                      denominator = ~cant_personas,
                      design = ps_pps)

Ingreso_percapita=bind_cols(as.data.frame(ratio_est$ratio),as.data.frame(sqrt(ratio_est$var)))%>%
  rename(Ingreso_Percapita=cant_personas...1,SE=cant_personas...2)

row.names(Ingreso_percapita)=NULL



```

| Ingreso Percapita | ${\sigma}$ |
|:-------:|:------:|
| 1726.827| 37.787|

**7. Calcule la estimación del error estándar del punto anterior, utilizando dos métodos de remuestreo: Jackknife y Bootstrap (con 1000 réplicas).**



Jackknife y Bootstrap son dos métodos de remuestreo que tienen como uno de sus objetivos obtener el ${\sigma}$ de estimadores no lineales.
La idea general de estos es que obtienen replicas de forma independiente a partir de la muestra original y posteriormente, para cada una de estas se calcula la estimación del parámetro. La varianza del estimador se obtiene a partir de observar la varianza entre las muestras.

Se comenzó realizando la estimación del error estándar bajo el método de Jackknife. Como el diseño es estratificado, se apliza Jackknife dentro de cada estrato. En este metodo se obtienen las réplicas eliminando de una unidad a la vez, en este caso, como el diseño es por conglomerados, eliminar una unidad se trauce en eliminar una UPM.  

```{r,echo=T}

#Jackknife

jkn=as.svrepdesign(design=ps_pps,type='JKn', replicate=1000)


te_jkn=svyratio(~ingreso_hog, ~cant_personas,jkn,return.replicates=TRUE)



```

| Ingreso Percapita (Jackknife) | ${\sigma}$ |
|:-------:|:------:|
| 1726.827| 37.884|

Luego, se estimó nuevamente el error estándar pero bajo el método de Bootstrap, con la variación de Rao-Wu, que se utiliza en diseños
aleatorios, estratificados y en varia etapas de selección, como es el caso. En este método se obtienen replicas de cada estrato bajo un MAS y luego de varios calculos se obtienen diferentes estimaciones del parámetro de intrés, estas estimaciones se utilizan para calcular la varianza del estimador.



```{r,echo=T}
#Bootstrap
set.seed(1)

boot=as.svrepdesign(design=ps_pps, type='subbootstrap', replicates=1000)

te_boot=svyratio(~ingreso_hog, ~cant_personas,boot,return.replicates=TRUE)



```
 | Ingreso Percapita (Bootstrap) | ${\sigma}$ |
|:-------:|:------:|
| 1726.827| 37.541|
 
 **Comparaciones:**

Tanto en el punto 6 como el 7 se obtuvieron estimaciones del ingreso per-capita y de su error estándar. 
La estimación del ingreso percapita fue la misma en los tres casos, la diferencia, aunque no mucha, surgió en la estimación del error estándar.
En todos los métodos las estimaciones se encuentran entre 37 y 38, siendo el método de Bootstrap el que obtuvo un menor %SE% con un valor de **37.541**, y Jackknife el mayor con **37.884**. En conlusión, si existe una diferencia entre las estimaciones de los métodos pero por lo menos en este caso dichas diferencias no son muy importantes.




**8. Realizar una visulización de la distribución empirica del estimador utilizando Bootstrap.**
**Interprete los resultados obtenidos.**

```{r, echo=FALSE,fig.cap="Gráfico 1: 1000 réplicas realizadas bajo boostrap"}
tibble(est= te_boot$replicates) %>% ggplot()+
                                    geom_histogram(aes(x=est),bins=20,fill='orange',color='white') +
                                    theme_minimal() +
                                    geom_vline(aes(xintercept=mean(te_boot$replicates)), color="blue", linetype="dashed", linewidth=1) +
                                    geom_vline(aes(xintercept=median(te_boot$replicates)), color="red", linetype="dotted", linewidth=1) +
                                    labs(title="Histograma de ingreso per cápita",
                                         subtitle = "",
                                        x="Ratios",
                                        y="Frecuencia",
                                        caption="Asímetría: -0.04  Curtosis: 0.03") +
                                    theme(plot.title = element_text(hjust = 0.5, size = 20),
                                          axis.title.x = element_text(size = 15),                
                                          axis.title.y = element_text(size = 15),                
                                          axis.text.x = element_text(size = 12),                 
                                          axis.text.y = element_text(size = 12))                  


#asimetría
#skewness(te_boot$replicates)


#Curtosis
#kurtosis(te_boot$replicates)-3


```

En el presente gráfico se puede observar la distribución del ingreso per cápita bajo el diseño de Bootstrap.
Podría decirse que se asemeja a la distribución de la normal, debido a que se puede observar que la distribución es aproximadamente simétrica, especialmente por las colas, donde la frecuencia es muy baja y va aumentando a medida que se acerca al centro de la distribución.

La distribución nos permite realizar las siguientes interpretaciones:	

- En muy pocas estimaciones se obtuvo un ingreso per cápita menor o igual a 1650 o mayor a 1800. 

- Las estimaciones se acumulan entre los 1700 y 1750.



**9. Estime la cantidad de personas pobres y no pobres (junto con sus márgenes de error).**
**Indique si los dominios de estimación son planeados o no planeados. Para este caso, utilice el Bootstrap realizado en los puntos anteriores.**
**Comente los resultados obtenidos y proponga estrategias para mejorar la precisión de la estimación obtenida.**

Al momento de realizar estimaciones en base a diseños muestrales puede ser de interés profundizar en algunas subpoblaciones de la propia muestra.
Estas subpoblaciones definidas por dominios pueden ser planeados o no planeados, en este caso donde ser o no ser pobre no es un aspecto considerado en el muestreo vamos a proceder a estimar el total de poblacion en estos dominios mediante la función `svyby` del paquete `Survey`.

La cantidad de personas pobres y no pobres que nos interesa estimar es la siguiente:

```{r}

personas_pobres = data.frame(Pobre=c("No pobre","Pobre"),
                             Freq=c(round((sum(U$cant_personas)-sum(U$cant_personas*U$pobre)),2),
                                    sum(U$cant_personas*U$pobre)))%>%
  mutate( Prop=round(Freq/sum(U$cant_personas),2))


personas_pobres%>%
  kable(.,caption="Tabla 5: Total de personas para los dominios de 'Pobre' y 'No pobre' ")%>%
  kable_styling(position = "center", latex_options = "HOLD_position")%>%
  kable_classic_2()


```

Mientras que con el diseño de boostrap de 1000 réplicas los totales están dados de la siguiente manera:


```{r,message=F,echo=F}




dominios = as.data.frame(svyby(~cant_personas , ~pobre , boot , svytotal)) %>%  
  rename(.,Cantidad_personas=cant_personas,SE=se,Pobre=pobre)%>%
  mutate(.,Pobre=ifelse(Pobre==1,"Pobre","No pobre"),
                        "2.5%"=Cantidad_personas-1.96*SE/sqrt(nrow(S)),
                        "97.5%"=Cantidad_personas+1.96*SE/sqrt(nrow(S))
         )

row.names(dominios)=NULL

dominios%>%
  kable(.,caption="Tabla 6: Estimación del total de personas para los dominios de 'Pobre' y 'No pobre' con 1000 réplicas")%>%
  kable_styling(position = "center", latex_options = "HOLD_position")%>%
  kable_classic_2()




```

```{r,message=F,echo=F,fig.cap="Gráfico 2: Estimación por dominios"}

  

ggplot(dominios, aes(x = Pobre, y = Cantidad_personas, fill = Pobre)) +
  geom_bar(stat = "identity", position = position_dodge(), color = "black") +
  labs(title = "Cantidad de Personas por Grupo (Pobre y No pobre)",
       x = "Grupo",
       y = "Cantidad de Personas") +
  theme_minimal() +
  theme(
    text = element_text(size = 15),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14),
    plot.title = element_text(size = 16, hjust = 0.5),
    legend.position = "NONE"
  ) +
  scale_fill_manual(values = c("Pobre" = "tomato1", "No pobre" = "steelblue"))



```




Para mejorar las estimaciones se podría:

- *Aumentar la cantidad de iteraciones en el bootstrap.*

A priori la idea de un mayor tamaño de muestra nos sugiere que vamos a contar con mejores estimaciones, no obstante vemos que esto no es tan así dado que los totales son los mismos e incluso con mayor varianza, por lo que descartamos esta idea.


```{r,message=F,echo=F}

#Aumentando la cantidad de replicas


set.seed(1)
boot_2000=as.svrepdesign(design=ps_pps, type='subbootstrap', replicates=2000)

dominios_2000 = as.data.frame(svyby(~cant_personas, ~pobre,boot_2000,svytotal)) %>% 
  rename(.,Cantidad_personas=cant_personas,SE=se,Pobre=pobre)%>%
  mutate(.,Pobre=ifelse(Pobre==1,"Pobre","No pobre"),
                        "2.5%"=Cantidad_personas-1.96*SE/sqrt(nrow(S)),
                        "97.5%"=Cantidad_personas+1.96*SE/sqrt(nrow(S))
         )


row.names(dominios_2000)=NULL


dominios_2000%>%
  kable(.,caption="Tabla 7: Estimación del total de personas para los dominios de 'Pobre' y 'No pobre' con 2000 replicas")%>%
  kable_styling(position = "center", latex_options = "HOLD_position")%>%
  kable_classic_2()




```





- *Ajustar los ponderadores mediante post-estratificación:*



Como siguiente estrategia nos valimos de la postestratificación por hogares pobres.
En nuestro caso contamos con la información de cual es la cantidad de hogares pobres, entonces con ese dato reponderamos con la función `postStratify` según estos para conseguir las siguientes estimaciones.

Vemos en este caso como las estimaciones permiten estimar de mejor forma la pobreza y en ambos casos con menor error que sin haber reponderado.

```{r, echo=T, message=F}


hogares_pobres = U  %>% group_by(.,pobre) %>% summarise(Freq = n()) #Frecuencias poblacionales de pobres





ps_pps_postestr = postStratify(boot, strata = ~pobre, population = hogares_pobres) #Ponderadores ajustados por post-estratificacion

```

```{r, echo=F, message=F}


post_estrati = as.data.frame(svyby(~cant_personas, ~pobre, ps_pps_postestr, svytotal))%>% 
  rename(.,Cantidad_personas=cant_personas,SE=se,Pobre=pobre)%>%
  mutate(.,Pobre=ifelse(Pobre==1,"Pobre","No pobre"),
                        "2.5%"=Cantidad_personas-1.96*SE/sqrt(nrow(S)),
                        "97.5%"=Cantidad_personas+1.96*SE/sqrt(nrow(S))
         )

row.names(post_estrati)=NULL

post_estrati%>%
  kable(.,caption="Tabla 8: Estimación del total de personas para los dominios de 'Pobre' y 'No pobre' mediante postestratificación")%>%
  kable_styling(position = "center", latex_options = "HOLD_position")%>%
  kable_classic_2()

```


- *Estimador de Hayek*

$$
Y_{\text{HAYEK},d} = N_d \tilde{y}_{sd}
$$

donde:

- \(N_d\) es el tamaño total del dominio \(d\).

- \(\tilde{y}_{sd}\) es la media muestral de la variable de interés en el dominio \(d\).

Esta sería la alternativa más viable en el marco de un muestreo complejo por conglomerados, implica conocer el tamaño de los dominios dentro de cada conglomerado pero agrega más información a la construcción del estimador.
Al tener más información lo vuelve más confiable que el estimador *HT*, incluso en situaciones donde la representación de los dominios es chica.


```{r,echo=F,message=F}

#Armado de gráficos para resumen

parametros =data.frame(
  Pobre = c("No pobre", "Pobre"),
  Cantidad_personas = c(1077511, 145899),
  SE = c(0, 0),
  low = c(0, 0),
  up = c(0, 0)
)

# Crear los dataframes
dominios = data.frame(
  Pobre = c("No pobre", "Pobre"),
  Cantidad_personas = c(1051268.5, 159766.9),
  SE = c(23581.50, 25549.17),
  low = c(1050113, 158515),
  up = c(1052424.0, 161018.8)
)

dominios_2000 = data.frame(
  Pobre = c("No pobre", "Pobre"),
  Cantidad_personas = c(1051268.5, 159766.9),
  SE = c(24008.53, 25761.55),
  low = c(1050092.0, 158504.5),
  up = c(1052444.9, 161029.2)
)

post_estrati = data.frame(
  Pobre = c("No pobre", "Pobre"),
  Cantidad_personas = c(1057998.4, 148813.4),
  SE = c(19979.58, 11853.15),
  low = c(1057019.4, 148232.6),
  up = c(1058977.4, 149394.2)
)

# Añadir una columna para identificar los conjuntos de datos
dominios$Estrategia = "Réplicas1000"
dominios_2000$Estrategia = "Réplicas2000"
post_estrati$Estrategia = "Postestratificacion"
parametros$Estrategia = "Parametros"

# Combinar los dataframes
data = rbind(dominios, dominios_2000, post_estrati)

data2 = rbind(parametros,dominios, dominios_2000, post_estrati)

```



# Conclusiones:

Como se mencionó anteriormente, uno de los objetivos de este proyecto era realizar estimaciones de diferentes parámetros para posteriormente compararlos con sus verdaderos valores.

Algunas de las comparaciones:

- El total de personas se estimó en **1.211.035** y el verdadero valor es **1.223.410**

- El ingreso promedio de los hogares se estimó en **4619** y el verdadero valor es **4653**.

- La proporción de hogares pobres se estimó en **0.085** y su verdadero valor es **0.07955**.

- El ingreso per cápita se estimó en **1727** y su verdadero valor es de **1722**.

- El total de personas pobres se estimó en **148813** y su verdadero valor es de **145899**.


Las estimaciones realizadas fueron buenas ya que no difieren mucho con respecto a los verdaderos valores de los parámetros. Esto nos lleva a poder afirmar, por lo menos en este caso, que el diseño propuesto, estratificado, por conglomerados y en dos etapas de selección, es un buen diseño.

Por otra parte para el caso de de estimar el total de los dominios *Pobre* y *No pobre* es mejor ajustar los ponderadores por medio de postestratificación según la variable de interés.


```{r,echo=F,fig.cap="Gráfico 4: Comparación de cantidad de personas para cada estrategia"}


ggplot(data2, aes(x = Pobre, y = Cantidad_personas, fill = Estrategia)) +
  geom_bar(stat = "identity", position = position_dodge(width = 1)) +
  labs(title = "Gráfico de barras agrupadas por categoría y estrategia",
       x = "Categoría",
       y = "Cantidad de Personas")+
 scale_fill_manual(values = c("Réplicas1000" = "palegreen",
                              "Réplicas2000" = "palegreen4",
                              "Postestratificacion" = "tan1",
                              "Parametros"="tomato1")) +
  theme_minimal()
```


```{r,echo=F,fig.cap="Gráfico 5: Comparación desvio standard de Cantidad de Personas por Categoría y estrategia"}


ggplot(data, aes(x = Pobre, y = SE, fill = Estrategia)) +
  geom_bar(stat = "identity", position = position_dodge(width = 1)) +
  labs(title = "Gráfico de barras agrupadas por categoría y estrategia",
       x = "Categoría",
       y = "Cantidad de Personas") +
  scale_fill_manual(values = c("Réplicas1000" = "palegreen",
                              "Réplicas2000" = "palegreen4",
                              "Postestratificacion" = "tan1")) +
  theme_minimal()


```

