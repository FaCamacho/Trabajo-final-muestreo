---
title: "Untitled"
output: html_document
date: "2024-06-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#INTRODUCCIÓN

El objetivo de este proyecto es realizar estimaciones de diferentes parámetros a partir de varios de los metodos ya vistos en clase.
Para cumplir el objetivo la obtención de la muestra es una etapa clave, y para esta se comenzó seleccionando una muestra aleatoria de los hogares de Montevideo bajo un
diseño estratificado, por conglomerados y en dos etapas de selección. Siendo las UPM las manzanas y la USM los hogares.
Para la selección de las UPM y posteriormente las USM se combinaron diferentes diseños según lo pautado.
Finalmente, una vez obtenidas las muestras y las estimaciones se realizaron comparaciones obteniendo así diferentes conclusiones.



### Paquetes
```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(survey)
library(srvyr)
library(sampling)


U <- read_csv("Montevideo GR1.csv")

U=Montevideo_GR1

options(scipen = 9999)


```




Analisis previo

```{r}

str(U)
summary(U)

# computamos totales de las variables y N
pop_total = U %>% summarise(Total_personas=sum(cant_personas),
                 Desocupados=sum(desocupados),
                 Ocupados=sum(ocuopados),
                 Pobres=sum(pobre),
                 N=n())
pop_total



```




1. Calcule el tamano de muestra para obtener un margen de error de ±3% a un 95%
de confianza para estimar cualquier proporcion poblacional. Asuma un efecto de
diseno de 1.5.

Para obtener el tamaño de muestra para cualquier proporción se utilizó la formula:

  n = (((z^2 * p * (1-p)) / moe^2) * moe )

Como se pedía un 95% de confianza, alfa tomó el valor de 0,05. Llevando a que z(1-alfa) fuera el valor de la distribución normal en el cuantil 0,975.
Posteriormente se asumió que p tomaba el valor de 0,5 y se sustituyó moe (margen de error) por 0,03, tal como pide la letra.



```{r}

n = round((((1.96^2 * 0.5 * (1-0.5)) / 0.03^2) * 1.5 ),0)

n

N_II = length(U) #cantidad de hogares

```



2. Con el tamano de muestra calculado en el punto anterior, asigne el mismo por
estrato de forma optima, utilizando como variable auxiliar el ingreso del hogar.

Se comenzó calculando para cada estrato su tamaño y las medidas de resumen (total, promedio y desvío) de la variable auxiliar, ingreso_hog.
Posteriormente, algunos de estos resultados fueron utilizados junto con el tamaño de muestra calculado en el punto anterior para obtener el tamaño de muestra de cada estrato según la asignación optima. 


```{r}



tam = U %>% group_by(estrato) %>% summarise(N=n(),
                                               tot_ing=sum(ingreso_hog),
                                               prom_ing=mean(ingreso_hog),
                                               sd_ig=sd(ingreso_hog),)

tam = tam %>% mutate(n_opt=round(n*N*sd_ig/sum(N*sd_ig),0))

tamano= as.vector(tam %>% select(.,n_opt))

```





3. Seleccione una muestra bajo el diseño propuesto (aleatorio, estratificado, por conglomerados y en 2 etapas de selección). Utilice como semilla el número de grupo al que pertenece.

```{r}


S=c()


#Cantidad de hogares por estrato
U %>% count(estrato)

#Cantidad de hogares por UPM (Manzana)
(U   %>%  count(manzana) )

#Cantidad de personas por UPM (manzana)

U_upm =U   %>%  group_by(manzana)   %>% summarise(MOS=sum(n()))


#Primera etapa

#Vamos a seleccionar 5 viviendas de cada UPM, cada UPM será seleccionada proporcional
#a la cantidad de personas



#Para el estrato 1

Estrato1 =  U   %>%  filter(,estrato==1)

#Cantidad de personas por UPM (manzana)

U_upm_estrato1 =U   %>%  filter(,estrato==1)   %>%  group_by(manzana)   %>% summarise(MOS=sum(n()))

m=tamano[["n_opt"]][1]/5 #La cantidad manzanas que vamos a sacar del estrato 1



#Acá ordené por MOS, en lugar de manzana
U_upm_estrato1 = U %>% filter(,estrato==1) %>%  group_by(manzana) %>% summarise(MOS=sum(n())) %>% arrange(MOS)



#Aquí estamos seleccionando la cantidad de manzanas del estrato
set.seed(1)

s_upm_1=sampling::strata(data=U_upm_estrato1,
                    stratanames = NULL,
                    size=m,
                    method='systematic',
                    pik=U_upm_estrato1$MOS)

s_upm_1 = getdata(U_upm_estrato1,s_upm_1) %>% rename(prob_upm=Prob)


#Segunda etapa
#Vamos a seleccionar mediante un diseño simple la cantidad de hogares dentro de las manzanas seleccionadas

U_usm_1 = U %>% left_join(s_upm_1 %>% select(manzana,prob_upm)) %>% filter(is.na(prob_upm)==FALSE)

U_usm_1= U_usm_1 %>% arrange(manzana)

set.seed(1)

s_1= sampling::strata(data=U_usm_1,
                    stratanames = 'manzana',
                    size=rep(5,m),
                    method='srswor')

s_1 = getdata(U_usm_1,s_1) %>% rename(prob_usm=Prob)

```




```{r}

#Intento de hacerlo con un for

Muestra = list("Estrato 1"=0,"Estrato 2"=0,"Estrato 3"=0,"Estrato 4"=0,"Estrato 5"=0)



for(i in 1:5) {
  
  
  #Primera etapa

#Vamos a seleccionar 5 viviendas de cada UPM, cada UPM será seleccionada proporcional
#a la cantidad de personas



#Para el estrato 1

m=round(tamano[["n_opt"]][i]/5,0) #La cantidad manzanas que vamos a sacar del estrato 

#Cantidad de personas por UPM (manzana)

#Acá ordené por MOS, en lugar de manzana
U_upm_estrato = U %>% filter(,estrato==i) %>%  group_by(manzana) %>% summarise(MOS=sum(n())) %>% arrange(MOS)



#Aquí estamos seleccionando la cantidad de manzanas del estrato
set.seed(1)

s_upm=sampling::strata(data=U_upm_estrato,
                    stratanames = NULL,
                    size=m,
                    method='systematic',
                    pik=U_upm_estrato$MOS)

s_upm = getdata(U_upm_estrato,s_upm) %>% rename(prob_upm=Prob)


#Segunda etapa
#Vamos a seleccionar mediante un diseño simple la cantidad de hogares dentro de las manzanas seleccionadas

U_usm= U %>% left_join(s_upm %>% select(manzana,prob_upm)) %>% filter(is.na(prob_upm)==FALSE)



U_usm= U_usm %>% arrange(manzana)

set.seed(1)

s= sampling::strata(data=U_usm,
                    stratanames = 'manzana',
                    size=rep(5,m),
                    method='srswor')

s = getdata(U_usm,s) %>% rename(prob_usm=Prob)
  

Muestra[[i]]=s
  
}

S = tibble::as_tibble(rbind(Muestra[[1]],Muestra[[2]],Muestra[[3]],Muestra[[4]],Muestra[[5]]))



```

4.

Calcule la estimacion puntual del $ingreso promedio$, $proporcion de hogares pobres$ y $total de personas$,
a nivel de toda la poblaci´on. Para cada estimacion se debe computar:
error estandar (SE), coeficiente de variacion, efecto de diseno y los margenes de
error al 95%. Interprete los resultados.


```{r}

#Realizado sobre el total de S

S = S %>% mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)





ps_pps= S %>% svydesign(ids=~manzana+ID,
                        strata = ~estrato, 
                     weights=~w,
                     data=.)

#Totales

totales = as.data.frame(svytotal(~ingreso_hog+cant_personas+pobre,ps_pps,deff=T))

N_gorro = sum(S$w)

#Estimadores

ingreso_gorro = totales[1,1]

cant_personas_gorro = totales[2,1]

desocupados_gorro = totales[3,1]


ingreso_promedio_gorro = ingreso_gorro/N_II #N es la cantidad de hogares (USM)

prop_desocupados_gorro = desocupados_gorro/N_II


estimadores = as.data.frame(matrix(c(ingreso_promedio_gorro,cant_personas_gorro,prop_desocupados_gorro)))


#estimadores= as.data.frame(matrix(ncol = 1,nrow = 3))


#Coeficientes de variacion

CV_ingreso_promedio_gorro = ingreso_promedio_gorro/totales[1,2]*100

CV_cant_personas_gorro = (cant_personas_gorro/N_gorro)/totales[2,2]*100

CV_prop_pobres_gorro = (prop_desocupados_gorro/N_gorro)/totales[3,2]*100


#Intervalo de confianza

confint(svytotal(~ingreso_promedio_gorro+cant_personas_gorro+prop_desocupados_gorro,ps_pps))


svytotal(~ingreso_hog+cant_personas+desocupados,ps_pps)  %>% confint()


#Resolver
#ps_pps  %>% summarise(survey_total(ingreso_promedio_gorro, vartype = c('cv','ci'), deff=TRUE))


#Parametros

parametros = U %>% summarise(Ingreso_promedio=mean(ingreso_hog),
                 Cantidad_personas=sum(cant_personas),
                 Prop_hogares_desocupados=mean(desocupados))
parametros


```
5. Para computar los errores estándar del punto anterior, ¿qué método para estimar
varianza se utilizó?

Para estimar la varianza R utiliza el método de la linealización de Taylor. Este realiza una aproximación lineal del estimador y permite estimar la varianza utilizando metodos para estimadores lineales.

```{r}
########################
#Realizado por estratos#
########################


#Estrato1


S_1 = Muestra[[1]]  %>%  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)


ps_pps_1= S_1 %>% svydesign(ids=~manzana+ID,
                     weights=~w,
                     data=.)

Paramatro_estrato1 = as.data.frame(svytotal(~ingreso_hog+cant_personas+desocupados,ps_pps_1))

#Estrato2


S_2 = Muestra[[2]]  %>%  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)


ps_pps_2= S_2 %>% svydesign(ids=~manzana+ID,
                     weights=~w,
                     data=.)

Paramatro_estrato2 = as.data.frame(svytotal(~ingreso_hog+cant_personas+desocupados,ps_pps_2))

#Estrato3


S_3 = Muestra[[3]]  %>%  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)


ps_pps_3= S_3 %>% svydesign(ids=~manzana+ID,
                     weights=~w,
                     data=.)

Paramatro_estrato3 = as.data.frame(svytotal(~ingreso_hog+cant_personas+desocupados,ps_pps_3))

#Estrato4


S_4 = Muestra[[4]]  %>%  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)


ps_pps_4= S_4 %>% svydesign(ids=~manzana+ID,
                     weights=~w,
                     data=.)

Paramatro_estrato4 = as.data.frame(svytotal(~ingreso_hog+cant_personas+desocupados,ps_pps_4))


#Estrato5


S_5 = Muestra[[5]]  %>%  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)


ps_pps_5= S_5 %>% svydesign(ids=~manzana+ID,
                     weights=~w,
                     data=.)

Paramatro_estrato5 = as.data.frame(svytotal(~ingreso_hog+cant_personas+desocupados,ps_pps_5))

totales = as.numeric(Paramatro_estrato1$total+Paramatro_estrato2$total+Paramatro_estrato3$total+Paramatro_estrato4$total+Paramatro_estrato5$total)

totales 
```

 6 Calcule el ingreso per c´apita en Montevideo (junto con su error est´andar). Indique
el tipo de par´ametro y qu´e m´etodo fue utilizado por defecto por el paquete survey
para la estimaci´on del error est´andar. Tenga en cuenta que el ingreso per c´apita se
calcula como



```{r}

# Calcular la estimación de razón
ratio_est <- svyratio(numerator = ~ingreso_hog,
                      denominator = ~cant_personas,
                      design = ps_pps)


ratio_est






```

