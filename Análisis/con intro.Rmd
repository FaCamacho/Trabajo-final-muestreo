---
title: "Untitled"
output: html_document
date: "2024-06-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#INTRODUCCIÓN

El objetivo de este proyecto es realizar estimaciones de diferentes parámetros a partir de varios de los metodos ya vistos en clase.
Para cumplir el objetivo la obtención de la muestra es una etapa clave, y para esta se comenzó seleccionando una muestra aleatoria de los hogares de Montevideo bajo un
diseño estratificado, por conglomerados y en dos etapas de selección. Siendo las UPM las manzanas y la USM los hogares.
Para la selección de las UPM y posteriormente las USM se combinaron diferentes diseños según lo pautado.
Finalmente, una vez obtenidas las muestras y las estimaciones se realizaron comparaciones obteniendo así diferentes conclusiones.



### Paquetes
```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(survey)
library(srvyr)
library(sampling)
library(here)
options(scipen = 9999)

U <- read_csv(here("Datos/Montevideo GR1.csv"))

```




Analisis previo

```{r,echo=TRUE}

#str(U)
summary(U)

```


```{r}
# computamos totales de las variables y N
pop_total = U %>% summarise(Total_personas=sum(cant_personas),
                 Desocupados=sum(desocupados),
                 Ocupados=sum(ocuopados),
                 Pobres=sum(pobre),
                 N=n())
pop_total

```




*1. Calcule el tamano de muestra para obtener un margen de error de ±3% a un 95%*
*de confianza para estimar cualquier proporcion poblacional. Asuma un efecto de diseno de 1.5.*

Para obtener el tamaño de muestra para cualquier proporción se utilizó la formula:

  $$n = ((z^2 * p*(1-p))/moe^2)*moe $$

Como se pedía un 95% de confianza, $\alpha$ tomó el valor de 0.05. Llevando a que $z_{(1-\alpha)}$  fuera el valor de la distribución normal en el cuantil 0.975.
Posteriormente se asumió que p tomaba el valor de 0.5 y se sustituyó moe (margen de error) por 0.03, tal como pide la letra.



```{r}

n = round((((1.96^2 * 0.5 * (1-0.5)) / 0.03^2) * 1.5 ),0)



N_II = nrow(U) #cantidad de hogares

```



*2. Con el tamano de muestra calculado en el punto anterior, asigne el mismo por estrato de forma optima, utilizando como variable auxiliar el ingreso del hogar.*

Se comenzó calculando para cada estrato su tamaño y las medidas de resumen (total, promedio y desvío) de la variable auxiliar, ingreso_hog.
Posteriormente, algunos de estos resultados fueron utilizados junto con el tamaño de muestra calculado en el punto anterior para obtener el tamaño de muestra de cada estrato según la asignación optima. 


```{r}



tam = U %>% 
  group_by(estrato) %>% 
  summarise(N=n(),
            tot_ing=sum(ingreso_hog),
            prom_ing=mean(ingreso_hog),
            sd_ig=sd(ingreso_hog),) %>%
  mutate(n_opt=round(n*N*sd_ig/sum(N*sd_ig),0))


tamano= as.vector(tam %>% select(.,n_opt))


```


*3. Seleccione una muestra bajo el diseño propuesto (aleatorio, estratificado, por conglomerados y en 2 etapas de selección).*
*Utilice como semilla el número de grupo al que pertenece.*


```{r, echo=T}


Muestra = list("Estrato 1"=0,"Estrato 2"=0,"Estrato 3"=0,"Estrato 4"=0,"Estrato 5"=0)



for(i in 1:5) {
  
  
  #Primera etapa

#Vamos a seleccionar 5 viviendas de cada UPM, cada UPM será seleccionada proporcional
#a la cantidad de personas



#Para el estrato 1

m=round(tamano[["n_opt"]][i]/5,0) #La cantidad manzanas que vamos a sacar del estrato 

#Cantidad de personas por UPM (manzana)

#Acá ordené por MOS, en lugar de manzana
U_upm_estrato = U %>% filter(,estrato==i) %>%  group_by(manzana) %>% summarise(MOS=sum(n())) %>% arrange(MOS)



#Aquí estamos seleccionando la cantidad de manzanas del estrato
set.seed(1)

s_upm=sampling::strata(data=U_upm_estrato,
                    stratanames = NULL,
                    size=m,
                    method='systematic',
                    pik=U_upm_estrato$MOS)

s_upm = getdata(U_upm_estrato,s_upm) %>% rename(prob_upm=Prob)


#Segunda etapa
#Vamos a seleccionar mediante un diseño simple la cantidad de hogares dentro de las manzanas seleccionadas

U_usm= U %>% left_join(s_upm %>% select(manzana,prob_upm)) %>% filter(is.na(prob_upm)==FALSE)



U_usm= U_usm %>% arrange(manzana)

set.seed(1)

s= sampling::strata(data=U_usm,
                    stratanames = 'manzana',
                    size=rep(5,m),
                    method='srswor')

s = getdata(U_usm,s) %>% rename(prob_usm=Prob)
  

Muestra[[i]]=s
  
}

S = tibble::as_tibble(rbind(Muestra[[1]],Muestra[[2]],Muestra[[3]],Muestra[[4]],Muestra[[5]])) %>%
  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)



```

*4. Calcule la estimacion puntual del ingreso promedio, proporcion de hogares pobres y total de personas ,a nivel de toda la población*

*Para cada estimacion se debe computar:*
 *- Error estandar (SE)*
 *- Coeficiente de variacion*
 *- Efecto de diseno*
 *- Margenes de error al 95%.*
 
 *Interprete los resultados.*
 
 
 
```{r,echo=T}

#Diseño estratificado en dos etapas 
ps_pps = S %>% svydesign(ids=~manzana+ID,
                        strata = ~estrato, 
                     weights=~w,
                     data=.)


#Ingreso promedio

ingreso_promedio_gorro = cross_join( as.data.frame(svymean(~ingreso_hog,ps_pps,deff=T)),
                                     as.data.frame(confint(svymean(~ingreso_hog,ps_pps,deff=T))))%>%
                          rename(.,Estimacion_puntual=mean,SE=ingreso_hog)%>%
                              mutate(.,CV=SE/Estimacion_puntual)


#Proporcion de hogares pobres


hogares_pobres_gorro = cross_join( as.data.frame(svymean(~pobre,ps_pps,deff=T)),
                                     as.data.frame(confint(svymean(~pobre,ps_pps,deff=T))))%>%
                            rename(.,Estimacion_puntual=mean,SE=pobre)%>%
                              mutate(.,CV=SE/Estimacion_puntual)


#Total de personas

total_personas_gorro = cross_join( as.data.frame(svytotal(~cant_personas,ps_pps,deff=T)),
                                     as.data.frame(confint(svytotal(~cant_personas,ps_pps,deff=T))))%>%
                          rename(.,Estimacion_puntual=total,SE=cant_personas)%>%
                              mutate(.,CV=SE/(as.data.frame(svymean(~cant_personas,ps_pps,deff=T))$mean) )

#Totales

estimadores =round(rbind(ingreso_promedio_gorro,hogares_pobres_gorro,total_personas_gorro),3)%>%
  select(.,1,2,6,4,5,3)

rownames(estimadores) <- c("Ingreso promedio","Proporcion hogares pobres","Total de personas")


```
 

*5. Para computar los errores estándar del punto anterior, ¿qué método para estimar varianza se utilizó?*

Para estimar la varianza se utilizó el método del último conglomerado junto con la linealización de Taylor. En este método se asume que la mayor variabilidad en la estimación proviene de la primera etapa del muestreo y que las manzanas (UPM) son seleccionadas con reposición. Luego el método de la linealización de Taylor realiza una aproximación lineal del estimador y permite estimar la varianza utilizando métodos para estimadores lineales.

Survey, el paquete que se utilizó en el punto anterior por defecto utiliza la formula: -


 *6. Calcule el ingreso per cápita en Montevideo (junto con su error estándar).*
*Indique el tipo de parámetro y qué método fue utilizado por defecto por el paquete survey para la estimación del error estándar.*



```{r}

# Calcular la estimación de razón
ratio_est <- svyratio(numerator = ~ingreso_hog,
                      denominator = ~cant_personas,
                      design = ps_pps)


ratio_est$ratio

sqrt(ratio_est$var)


```
*7. Calcule la estimación del error estándar del punto anterior, utilizando dos métodos de remuestreo: Jackknife y Bootstrap (con 1000 réplicas).*
*Compare los resultados obtenidos.*

*8. Realizar una visulización de la distribución empirica del estimador utilizando Bootstrap*.
*Interprete los resultados obtenidos.*


#Borradores



```{r}
########################
#Realizado por estratos#
########################


#Estrato1


S_1 = Muestra[[1]]  %>%  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)


ps_pps_1= S_1 %>% svydesign(ids=~manzana+ID,
                     weights=~w,
                     data=.)

Paramatro_estrato1 = as.data.frame(svytotal(~ingreso_hog+cant_personas+desocupados,ps_pps_1))

#Estrato2


S_2 = Muestra[[2]]  %>%  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)


ps_pps_2= S_2 %>% svydesign(ids=~manzana+ID,
                     weights=~w,
                     data=.)

Paramatro_estrato2 = as.data.frame(svytotal(~ingreso_hog+cant_personas+desocupados,ps_pps_2))

#Estrato3


S_3 = Muestra[[3]]  %>%  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)


ps_pps_3= S_3 %>% svydesign(ids=~manzana+ID,
                     weights=~w,
                     data=.)

Paramatro_estrato3 = as.data.frame(svytotal(~ingreso_hog+cant_personas+desocupados,ps_pps_3))

#Estrato4


S_4 = Muestra[[4]]  %>%  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)


ps_pps_4= S_4 %>% svydesign(ids=~manzana+ID,
                     weights=~w,
                     data=.)

Paramatro_estrato4 = as.data.frame(svytotal(~ingreso_hog+cant_personas+desocupados,ps_pps_4))


#Estrato5


S_5 = Muestra[[5]]  %>%  mutate(prob_total=prob_upm*prob_usm,
                w=1/prob_total)


ps_pps_5= S_5 %>% svydesign(ids=~manzana+ID,
                     weights=~w,
                     data=.)

Paramatro_estrato5 = as.data.frame(svytotal(~ingreso_hog+cant_personas+desocupados,ps_pps_5))

totales = as.numeric(Paramatro_estrato1$total+Paramatro_estrato2$total+Paramatro_estrato3$total+Paramatro_estrato4$total+Paramatro_estrato5$total)

totales 
```

